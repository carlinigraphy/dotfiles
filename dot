#!/usr/bin/env bash
# vim: ft=bash tw=80
#
#-------------------------------------------------------------------------------
# General idea:
#  `dot add` moves a local dot{file,dir} to a directory here
#     - optionally under a subdirectory to serve as a "tag"
#     - e.g., the same file can have slight differences across tags
#     - just use `nvim -d` to manage differences between tags
#     - helps for macOS bashrc vs. arch bashrc
#  `dot deploy` replaces the current file with the one from here
#     - don't know if I want to do it with symlinks or not
#     - before any destructive action is taken, saves backup of current file
#  * safe:
#     - in-place, versioned backups before replacing any file
#  * easy:
#     - auto-completion
#     - flexible organizational system
#
#--- TODO ----------------------------------------------------------------------
# [ ] Validate that entries in ./dotfiles/ match up with entires in ./database
#
#-------------------------------------------------------------------------------
# Thinkies:
# Validation
#  - when adding, `src' may not already exist
#  - when adding, `dst` may not be a symlink already
#
#-------------------------------------------------------------------------------

set -e

declare -g  THIS=$( realpath "${BASH_SOURCE[0]}" )
declare -g  PROGDIR=$( cd "$(dirname "${THIS}")" ; pwd )
declare -g  DATABASE="${PROGDIR}/database"

declare -gA MAP=()   # { source -> dest }
#declare -gA RMAP=()  # { dest -> source[] }
#declare -g  SOURCE_LIST=
#declare -gi _SOURCE_LIST_IDX=0
## For easier diff functionality. If the destination is a file, exec `nvim -d`
## for all sources that refer to the destination.

touch "${DATABASE}" -a
mkdir -p "${PROGDIR}/dotfiles"

# PROGDIR/
#  +-- database
#  `-- dotfiles/
#       +-- bash/
#       |    `-- .bashrc
#       `-- nvim/
    
function usage {
   declare -i status="$1"
   cat <<EOF

usage: ${THIS##*/} [option] command

commands:
   add FILE          assume ownership of \$FILE
   deploy FILE       symlink owned \$FILE to host
   ls                print owned files

EOF
exit "$status"
}


function load_data {
   local src dst

   declare -p DATABASE
   cat $DATABASE

   while IFS=$'\t' read -r dst src ; do
      MAP["${src}"]="${dst}"
   done < "${DATABASE}"
}


function write_data {
   for src in "${!MAP[@]}" ; do
      local dst="${MAP["${src}"]}"
      printf '%s\t%s\n' "${src}" "${dst}"
   done > "${DATABASE}"
}


#function new_src_list {
#   local name="__SOURCE_LIST_$(( ++_SOURCE_LIST_IDX ))"
#   declare -ga "$name"
#   declare -g SOURCE_LIST="$name"
#}


function add_entry {
   # `dot add ~/.bashrc bash/laptop/.bashrc`
   #          ^- dst    ^- src
   #
   # Must...
   #  strip leading ${HOME}
   #  fail if not found

   # `src' and `dst' appear flipped, but where the file ORIGINATES is where it
   # must be deployed back to: the destination.
   local dst="$1"
   local src="$2"

   if [[ ! $dst || ! -f $dst ]] ; then
      printf 'File does not exist\n'
      printf '   %s\n'  "$dst"
      exit 1
   fi

   if [[ $dst =~ ^[/~] ]] ; then
      printf 'Destination may not be absolute. Is relative to\n'
      printf '   %s\n'  "${PROGDIR}"
      exit 1
   fi

   local relative_dst="${dst#$HOME/}"
   if [[ $dst == "${relative_dst}" ]] ; then
      printf '[dot] only owns files/dirs under $HOME/\n'
      printf '  %s\n'  "$dst"
      exit 1
   fi

   # Hoping to catch some errors early, save time before parsing the data file.
   load_data

   if [[ "${MAP[$src]}" ]] ; then
      printf '[dot] already owns ~/%s\n'  "${relative_dst}"
      printf '   %s\n'  "${MAP[$src]}" 
   fi

   printf 'Assuming ownership of\n'
   printf '   ~/%s\n'  "$relative_dst"
   printf 'as\n'
   printf '   %s\n'  "${relative_src}"
}


function list_tree {
   # `cd` just kinda nice for better formatting with `tree`. Shows directories
   # relative to ./dotfiles/ instead of wherever you were in the filesystem.
   ( cd "${PROGDIR}" && tree --prune --noreport -a -I .hg dotfiles ) || {
      printf 'Unable to cd to %s.\n' "$PROGDIR"
      exit 1
   }
}


case "$1" in
   '' | -h | --help)
      usage 0 ;;

   add)
      shift ; add_entry "$@" ;;

   deploy)
      shift ; deploy_entry "$@" ;;

   ls | tree)
      shift ; list_tree "$@" ;;


   ## While testing.
   t) load_data ; declare -p MAP ;;


   *) if [[ -f $1 || -d $1 ]] ; then
         printf 'No command specified. Perhaps you meant:\n'
         printf "   \`${THIS} add  ${1/$HOME/'~'}  $2\`\n"
      else
         printf 'Unknown option: %s\n' "$1"
      fi
      exit 1
      ;;
esac
